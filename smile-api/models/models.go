// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package models

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type DoingByIDUnion interface {
	IsDoingByIDUnion()
}

type Auth struct {
	Login bool   `json:"login"`
	Token string `json:"token"`
}

type Comment struct {
	ID        int        `json:"id"`
	PostID    int        `json:"postId"`
	Commenter *User      `json:"commenter"`
	CreatedAt time.Time  `json:"createdAt"`
	Content   string     `json:"content"`
	Reply     []*Comment `json:"reply"`
}

func (Comment) IsDoingByIDUnion() {}

type CommentField struct {
	PostID  int    `json:"postId"`
	Content string `json:"content"`
	UserID  string `json:"user_id"`
	ReplyID *int   `json:"reply_id"`
}

type ContributorUser struct {
	ID          int       `json:"id"`
	ContribAt   time.Time `json:"contribAt"`
	Contributor *User     `json:"contributor"`
}

type EditCommentField struct {
	ID      int    `json:"id"`
	Content string `json:"content"`
}

type Embed struct {
	ID        int     `json:"id"`
	PostID    int     `json:"postId"`
	Thumbnail *int    `json:"thumbnail"`
	Video     *string `json:"video"`
}

type LoginUser struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type Post struct {
	ID           int                `json:"id"`
	Author       *User              `json:"author"`
	Title        string             `json:"title"`
	CreatedAt    time.Time          `json:"createdAt"`
	Content      string             `json:"content"`
	Status       Status             `json:"status"`
	LastEditedAt *time.Time         `json:"last_edited_at"`
	LastEditedBy *string            `json:"last_edited_by"`
	Embed        *Embed             `json:"embed"`
	Rating       *Rating            `json:"rating"`
	Contributor  []*ContributorUser `json:"contributor"`
	Comment      []*Comment         `json:"comment"`
}

func (Post) IsDoingByIDUnion() {}

type PostField struct {
	AuthorID string `json:"author_id"`
	Title    string `json:"title"`
	Content  string `json:"content"`
	Status   Status `json:"status"`
}

type Rating struct {
	ID        int   `json:"id"`
	Post      *Post `json:"post"`
	View      int   `json:"view"`
	Share     int   `json:"share"`
	Comment   int   `json:"comment"`
	VideoRate *int  `json:"video_rate"`
}

type User struct {
	UserID       string    `json:"user_id"`
	Username     string    `json:"username"`
	JoinAt       time.Time `json:"joinAt"`
	LastEditedAt time.Time `json:"lastEditedAt"`
	Fullname     string    `json:"fullname"`
	Password     string    `json:"password"`
	Avatar       string    `json:"avatar"`
	IsAdmin      *bool     `json:"isAdmin"`
	Post         []*Post   `json:"post"`
}

func (User) IsDoingByIDUnion() {}

type UserField struct {
	Username string `json:"username"`
	Email    string `json:"email"`
	Fullname string `json:"fullname"`
	Password string `json:"password"`
	Avatar   string `json:"avatar"`
}

type Status string

const (
	StatusPublish Status = "publish"
	StatusDraft   Status = "draft"
	StatusHide    Status = "hide"
)

var AllStatus = []Status{
	StatusPublish,
	StatusDraft,
	StatusHide,
}

func (e Status) IsValid() bool {
	switch e {
	case StatusPublish, StatusDraft, StatusHide:
		return true
	}
	return false
}

func (e Status) String() string {
	return string(e)
}

func (e *Status) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Status(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Status", str)
	}
	return nil
}

func (e Status) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GenericEnum string

const (
	GenericEnumUser    GenericEnum = "user"
	GenericEnumComment GenericEnum = "comment"
	GenericEnumPost    GenericEnum = "post"
)

var AllGenericEnum = []GenericEnum{
	GenericEnumUser,
	GenericEnumComment,
	GenericEnumPost,
}

func (e GenericEnum) IsValid() bool {
	switch e {
	case GenericEnumUser, GenericEnumComment, GenericEnumPost:
		return true
	}
	return false
}

func (e GenericEnum) String() string {
	return string(e)
}

func (e *GenericEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GenericEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid genericEnum", str)
	}
	return nil
}

func (e GenericEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GenericOptionEnum string

const (
	GenericOptionEnumRemove GenericOptionEnum = "remove"
	GenericOptionEnumFind   GenericOptionEnum = "find"
)

var AllGenericOptionEnum = []GenericOptionEnum{
	GenericOptionEnumRemove,
	GenericOptionEnumFind,
}

func (e GenericOptionEnum) IsValid() bool {
	switch e {
	case GenericOptionEnumRemove, GenericOptionEnumFind:
		return true
	}
	return false
}

func (e GenericOptionEnum) String() string {
	return string(e)
}

func (e *GenericOptionEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GenericOptionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid genericOptionEnum", str)
	}
	return nil
}

func (e GenericOptionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
